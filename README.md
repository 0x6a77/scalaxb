scalaxb
=======

scalaxb is an XML data-binding tool for Scala that supports W3C XML 
Schema (xsd) as the input file.

Status
------

This is still at ALPHA state, and many things may not work.
I'd really appreciate if you could run it against your favorite xsd
file and let me know the result.

Installation
------------

scalaxb is tested only under Scala 2.8. You can install it using sbaz:

    $ sudo sbaz update
    $ sudo sbaz install scalaxb

and upgrade it if you've installed it before:

    $ sudo sbaz update
    $ sudo sbaz upgrade

or build from source:

    $ git clone git://github.com/eed3si9n/scalaxb.git scalaxb
    $ cd scalaxb
    $ sbt sbaz

See the file called INSTALL for details.

Usage
-----

    $ scalaxb [options] <schema_file>...

      -d <directory> | --outdir <directory>
            generated files will go into <directory>
      -p <package> | --package <package>
            specifies the target package
      -p:<namespaceURI>=<package> | --package:<namespaceURI>=<package>
            specifies the target package for <namespaceURI>
      --class-prefix <prefix>
            prefixes generated class names
      --param-prefix <prefix>
            prefixes generated parameter names
      --wrap-contents <complexType>
            wraps inner contents into a seperate case class
      -v | --verbose
            be extra verbose
      <schema_file>
            input schema to be converted

Documents
---------

Further info is available at [scalaxb.org](http://scalaxb.org/).

Example
-------

Suppose you have address.xsd:

    <schema targetNamespace="http://www.example.com/IPO"
            xmlns="http://www.w3.org/2001/XMLSchema"
            xmlns:ipo="http://www.example.com/IPO">
      <complexType name="Address">
        <sequence>
          <element name="name"   type="string"/>
          <element name="street" type="string"/>
          <element name="city"   type="string"/>
        </sequence>
      </complexType>
    </schema>

You then run the following:

    $ scalaxb address.xsd -p ipo
    
You should see output like:

    generated ./address.scala.
    generated ./xmlprotocol.scala.
    generated ./scalaxb.scala.
    
address.scala contains a case class representing the complex type:

    // Generated by <a href="http://scalaxb.org/">scalaxb</a>.
    package ipo

    case class Address(name: String,
      street: String,
      city: String)
      
xmlprotocol.scala contains `XMLProtocol` trait and its implementation `DefaultXMLProtocol`, which
defines type class instance to convert XML documents into `Address`, and `Address` back to XML.

    // Generated by <a href="http://scalaxb.org/">scalaxb</a>.
    package ipo

    /**
    usage:
    import scalaxb._
    import Scalaxb._
    import ipo._
    import DefaultXMLProtocol._

    val obj = fromXML[Foo](node)
    val document = toXML[Foo](obj, "foo", defaultScope)
    **/
    trait XMLProtocol extends scalaxb.XMLStandardTypes {
      implicit lazy val IpoAddressFormat: scalaxb.XMLFormat[ipo.Address] = buildIpoAddressFormat
      def buildIpoAddressFormat: scalaxb.XMLFormat[ipo.Address]


    }

    object DefaultXMLProtocol extends DefaultXMLProtocol with scalaxb.DefaultXMLStandardTypes {
      import scalaxb.Scalaxb._
      val defaultScope = toScope(None -> "http://www.example.com/IPO",
        Some("ipo") -> "http://www.example.com/IPO",
        Some("xsi") -> "http://www.w3.org/2001/XMLSchema-instance")  
    }

    trait DefaultXMLProtocol extends XMLProtocol {
      import scalaxb.Scalaxb._

      override def buildIpoAddressFormat = new DefaultIpoAddressFormat {}
      trait DefaultIpoAddressFormat extends scalaxb.ElemNameParser[ipo.Address] {
        val targetNamespace: Option[String] = Some("http://www.example.com/IPO")

        override def typeName: Option[String] = Some("Address")

        def parser(node: scala.xml.Node): Parser[ipo.Address] =
          (scalaxb.ElemName(targetNamespace, "name")) ~ 
          (scalaxb.ElemName(targetNamespace, "street")) ~ 
          (scalaxb.ElemName(targetNamespace, "city")) ^^
          { case p1 ~ p2 ~ p3 =>
          ipo.Address(fromXML[String](p1),
            fromXML[String](p2),
            fromXML[String](p3)) }

        def writesChildNodes(__obj: ipo.Address, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
          Seq.concat(toXML[String](__obj.name, None, Some("name"), __scope, false),
            toXML[String](__obj.street, None, Some("street"), __scope, false),
            toXML[String](__obj.city, None, Some("city"), __scope, false))

      }


    }

Finally, scalaxb.scala contains some of the helper classes to use the generated code.

How to use the generated code
-----------------------------

In your program, include all three of the generated files.
You need to call four `import` to use the generated classes along with the helper classes.

    import scalaxb._
    import Scalaxb._
    import ipo._
    import DefaultXMLProtocol._
    
To convert an XML node into a case class object, call `scalaxb.Scalaxb.fromXML[A]`:

    val shipTo = fromXML[Address](<shipTo>
        <name>foo</name>
        <street>1537 Paper Street</street>
        <city>Wilmington</city>
      </shipTo>)

In the above code, Scala compiler supplies `XMLFormat[Address]` into the implicit parameter off of the lexical scope.
It's actually `ipo.DefaultXMLProtocol.DefaultIpoAddressFormat.` Now you can write `shipTo.name` to retrieve the name value.

To convert the object back to XML, call `scalaxb.Scalaxb.toXML[A]`:

    val document = toXML[Address](shipTo, "shipTo", defaultScope)

Bug Reporting
-------------

You can send bug reports to [Issues](http://github.com/eed3si9n/scalaxb/issues),
send me a [tweet to @eed3si9n](http://twitter.com/eed3si9n), or email.

Licensing
---------

It's the MIT License. See the file called LICENSE.
     
Contacts
--------

- eed3si9n at gmail dot com
- [@eed3si9n](http://twitter.com/eed3si9n)
